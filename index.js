import { App } from "@slack/bolt";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { generateText, experimental_generateImage as generateImage } from "ai";
import "dotenv/config";

const hackai = createOpenRouter({
  apiKey: process.env.HACK_CLUB_AI_API_KEY,
  baseUrl: "https://ai.hackclub.com/proxy/v1",
});

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  socketMode: true,
  appToken: process.env.SLACK_APP_TOKEN,
});

app.command("/photo", async ({ ack, command, client }) => {
  await ack();

  const statusMessage = await client.chat.postMessage({
    channel: command.channel_id,
    text: `:loading2: Generating image with prompt: ${command.text}`,
  });

  try {
    const response = await fetch(
      "https://ai.hackclub.com/proxy/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.HACK_CLUB_AI_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "google/gemini-3-pro-image-preview",
          messages: [
            {
              role: "user",
              content: command.text,
            },
          ],
          modalities: ["image", "text"],
          image_config: {
            aspect_ratio: "1:1",
          },
        }),
      }
    );

    const data = await response.json();
    const imageBase64 =
      data.choices[0].message.images[0].image_url.url.split(",")[1];
    const imageBuffer = Buffer.from(imageBase64, "base64");

    await client.files.uploadV2({
      channel_id: command.channel_id,
      file: imageBuffer,
      filename: "generated_image.png",
      title: command.text,
      initial_comment: `Sure, here is your image for ${command.text}`,
      thread_ts: statusMessage.ts || statusMessage.thread_ts,
    });

    await client.chat.update({
      channel: command.channel_id,
      ts: statusMessage.ts,
      text: `${command.text} generated by ${command.user_name}`,
    });
  } catch (error) {
    console.error("Image Gen Error:", error);

    await client.chat.update({
      channel: command.channel_id,
      ts: statusMessage.ts,
      text: "Failed to generate image. Please try again.",
    });
  }
});

app.message(async ({ message, say, client }) => {
  if (message.subtype === "bot_message" || message.bot_id) return;
  if (message.thread_ts) return;
  if (!message.text) return;
  client.reactions.add({
    channel: message.channel,
    name: "loading",
    timestamp: message.ts,
  });
  const { response } = await generateText({
    model: hackai("google/gemini-2.5-flash"),
    system:
      "Format your response using Slack's mrkdwn syntax. Use *bold* for bold, _italics_ for italics, and <url|text> for links. For unordered lists, use a bullet point *. Do not use # for headers or markdown tables. Do not wrap the response in a markdown code block. Never mention that you are using special markdown.",
    prompt: message.text,
  });
  const responseText =
    response.messages[response.messages.length - 1].content[0].text;
  say({
    text: responseText,
    thread_ts: message.ts || message.thread_ts,
    mrkdwn: true,
  });
  client.reactions.remove({
    name: "loading",
    timestamp: message.ts,
    channel: message.channel,
    user: message.user.id,
  });
});

app.message(async ({ message, say, client }) => {
  if (!message.thread_ts) return;
  if (message.text && message.text.startsWith("/")) return;

  await client.reactions.add({
    channel: message.channel,
    name: "loading",
    timestamp: message.ts,
  });

  try {
    const threadHistory = await client.conversations.replies({
      channel: message.channel,
      ts: message.thread_ts,
    });

    const formattedHistory = (threadHistory.messages || [])
      .map((msg) => ({
        role: msg.bot_id ? "assistant" : "user",
        content: msg.text || "",
      }))
      .filter((msg) => msg.content.trim() !== "");

    const { text } = await generateText({
      model: hackai("google/gemini-2.5-flash"),
      system:
        "Format your response using Slack's mrkdwn syntax. Use *bold* for bold, _italics_ for italics, and <url|text> for links. For unordered lists, use a bullet point *. Do not use # for headers or markdown tables. Do not wrap the response in a markdown code block. Never mention that you are using special markdown.",
      messages: formattedHistory,
    });

    await say({
      text: text,
      thread_ts: message.thread_ts,
      mrkdwn: true,
    });
  } catch (error) {
    console.error(error);
  } finally {
    try {
      await client.reactions.remove({
        name: "loading",
        timestamp: message.ts,
        channel: message.channel,
      });
    } catch (e) {}
  }
});

(async () => {
  await app.start();
  app.logger.info("Gemini-Slack bot is running");
})();
