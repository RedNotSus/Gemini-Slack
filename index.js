import { App } from "@slack/bolt";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { generateText, experimental_generateImage as generateImage } from "ai";
import "dotenv/config";

const ALLOWED_CHANNEL = process.env.ALLOWED_CHANNEL_ID || "C0A0XPYSEEN";

const hackai = createOpenRouter({
  apiKey: process.env.HACK_CLUB_AI_API_KEY,
  baseUrl: "https://ai.hackclub.com/proxy/v1",
});

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  socketMode: true,
  appToken: process.env.SLACK_APP_TOKEN,
});

async function downloadSlackFile(url) {
  const response = await fetch(url, {
    headers: { Authorization: `Bearer ${process.env.SLACK_BOT_TOKEN}` },
  });
  if (!response.ok) throw new Error(response.statusText);
  const arrayBuffer = await response.arrayBuffer();
  return Buffer.from(arrayBuffer).toString("base64");
}

app.command("/photo", async ({ ack, command, client }) => {
  await ack();

  if (command.channel_id !== ALLOWED_CHANNEL) {
    try {
      await client.chat.postEphemeral({
        channel: command.channel_id,
        user: command.user_id,
        text: `This command only works in <#${ALLOWED_CHANNEL}>.`,
      });
    } catch (e) {}
    return;
  }
  const statusMessage = await client.chat.postMessage({
    channel: command.channel_id,
    text: `:loading2:  Generating image with prompt: ${command.text}`,
  });

  try {
    const response = await fetch(
      "https://ai.hackclub.com/proxy/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.HACK_CLUB_AI_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "google/gemini-3-pro-image-preview",
          messages: [
            {
              role: "user",
              content: command.text,
            },
          ],
          modalities: ["image", "text"],
          image_config: {
            aspect_ratio: "1:1",
          },
        }),
      }
    );

    const data = await response.json();
    const imageBase64 =
      data.choices[0].message.images[0].image_url.url.split(",")[1];
    const imageBuffer = Buffer.from(imageBase64, "base64");

    await Promise.all([
      client.files.uploadV2({
        channel_id: command.channel_id,
        file: imageBuffer,
        filename: "generated_image.png",
        title: command.text,
        initial_comment: `Sure, here is your image for ${command.text}`,
        thread_ts: statusMessage.ts || statusMessage.thread_ts,
      }),
      client.chat.update({
        channel: command.channel_id,
        ts: statusMessage.ts,
        text: `${command.text} generated by ${command.user_name}`,
      }),
    ]);
  } catch (error) {
    console.error("Image Gen Error:", error);

    await client.chat.update({
      channel: command.channel_id,
      ts: statusMessage.ts,
      text: "Failed to generate image. Please try again.",
    });
  }
});

app.message(async ({ message, say, client }) => {
  if (message.subtype === "bot_message" || message.bot_id) return;
  if (message.channel !== ALLOWED_CHANNEL) return;
  if (message.thread_ts) return;
  if (!message.text && !message.files) return;

  await client.reactions.add({
    channel: message.channel,
    name: "loading",
    timestamp: message.ts,
  });

  try {
    const messagesContent = [];

    if (message.text) {
      messagesContent.push({ type: "text", text: message.text });
    } else {
      messagesContent.push({ type: "text", text: " " });
    }

    if (message.files) {
      const file = message.files[0];
      if (file.url_private && file.mimetype.startsWith("image/")) {
        const base64Data = await downloadSlackFile(file.url_private);
        messagesContent.push({
          type: "image",
          image: base64Data,
        });
      }
    } else {
      const imageUrls = message.text
        ? message.text.match(/https?:\/\/\S+\.(png|jpg|jpeg|gif)/gi)
        : null;

      if (imageUrls) {
        for (const imageUrl of imageUrls) {
          const response = await fetch(imageUrl);
          const arrayBuffer = await response.arrayBuffer();
          const base64Data = Buffer.from(arrayBuffer).toString("base64");
          messagesContent.push({
            type: "image",
            image: base64Data,
          });
        }
      }
    }

    const { text } = await generateText({
      model: hackai("google/gemini-3-flash-preview"),
      system:
        "Format your response using Slack's mrkdwn syntax. Use *bold* for bold, _italics_ for italics, and <url|text> for links. For unordered lists, use a bullet point *. Do not use # for headers or markdown tables. Do not wrap the response in a markdown code block. Never mention that you are using special markdown.",
      messages: [
        {
          role: "user",
          content: messagesContent,
        },
      ],
    });

    await say({
      text: text,
      thread_ts: message.ts || message.thread_ts,
      mrkdwn: true,
    });
  } catch (error) {
    console.error(error);
  } finally {
    try {
      client.reactions.remove({
        name: "loading",
        timestamp: message.ts,
        channel: message.channel,
        user: message.user.id,
      });
    } catch (e) {}
  }
});

app.message(async ({ message, say, client }) => {
  if (message.channel !== ALLOWED_CHANNEL) return;
  if (!message.thread_ts) return;
  if (message.text && message.text.startsWith("/")) return;

  await client.reactions.add({
    channel: message.channel,
    name: "loading",
    timestamp: message.ts,
  });

  try {
    const threadHistory = await client.conversations.replies({
      channel: message.channel,
      ts: message.thread_ts,
    });

    const formattedHistory = (threadHistory.messages || [])
      .map((msg) => ({
        role: msg.bot_id ? "assistant" : "user",
        content: msg.text || "",
      }))
      .filter((msg) => msg.content.trim() !== "");

    const { text } = await generateText({
      model: hackai("google/gemini-3-flash-preview"),
      system:
        "Format your response using Slack's mrkdwn syntax. Use *bold* for bold, _italics_ for italics, and <url|text> for links. For unordered lists, use a bullet point *. Do not use # for headers or markdown tables. Do not wrap the response in a markdown code block. Never mention that you are using special markdown.",
      messages: formattedHistory,
    });

    await say({
      text: text,
      thread_ts: message.thread_ts,
      mrkdwn: true,
    });
  } catch (error) {
    console.error(error);
  } finally {
    try {
      await client.reactions.remove({
        name: "loading",
        timestamp: message.ts,
        channel: message.channel,
      });
    } catch (e) {}
  }
});

(async () => {
  await app.start();
  app.logger.info("Gemini-Slack bot is running");
})();
